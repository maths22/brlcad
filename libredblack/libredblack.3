.\" Set the interparagraph spacing to 1 (default is 0.4)
.PD 1v
.\"
.\" The man page begins...
.\"
.TH LIBREDBLACK 3 BRL/CAD
.\"
.SH NAME
libredblack \- red-black tree subroutines
.\"
.SH SYNOPSIS
\fB#include "redblack.h"
.\"
.PP
.B rb_tree *rb_create (description, nm_orders, order_funcs)
.br
.B char *description;
.br
.B int nm_orders;
.br
.B int (**order_funcs)();
.\"
.PP
.B rb_tree *rb_create1 (description, order_func)
.br
.B char *description;
.br
.B int (*order_func)();
.\"
.PP
.B void rb_extreme (tree, order, sense)
.br
.B rb_tree *tree;
.br
.B int order;
.br
.B int sense;
.\"
.PP
.B void rb_neighbor (order, sense)
.br
.B int order;
.br
.B int sense;
.\"
.PP
.B int rb_insert (tree, data)
.br
.B rb_tree *tree;
.br
.B void *data;
.\"
.PP
.B void *rb_search (tree, order, data)
.br
.B rb_tree *tree;
.br
.B int order;
.br
.B void *data;
.\"
.PP
.B void rb_walk (tree, order, visit)
.br
.B rb_tree *tree;
.br
.B int order;
.br
.B void (*visit)();
.\"
.\"
.SH DESCRIPTION
These subroutines implement red-black trees,
a form of balanced binary trees,
in such a way that all the basic dynamic set operations
(e.g., insertion, deletion, search, minimum, maximum,
predecessor, and successor)
require no more than
.IR "O(" "log " "n)"
time,
where
.I n
is the number of nodes.
They allow storage of arbitrary data structures
at tree nodes
and also support multiple simultaneous orders (trees)
on the same nodes.
The trees are based on comparison functions
like those used by
.I qsort(3).
.PP
.I rb_create
allocates storage for
and initializes
the tree header.
.I Description
is an explanatory comment that
.I libredblack
prints in its diagnostics,
.I nm_orders
is the number of simultaneous orders,
and
.I order_funcs
points to the table of comparison functions
(one for each order).
These are called with two arguments
that point to the elements being compared.
Each function must return an integer
less than, equal to, or greater than zero
according as the first argument is to be considered
less than, equal to, or greater than the second.
On success,
.I rb_create
returns a pointer to
an
.I rb_tree.
Otherwise, it returns
.I RB_TREE_NULL.
This pointer must be saved,
as it is a required argument to all the other subroutines.
.I rb_create1
is similar,
except that it creates a tree that supports only the single order
specified by
.I order_func.
.PP
.I rb_insert
creates a new node containing
.I data
and adds it to
.I tree.
The node is inserted in the appropriate place
in each order,
as determined by the comparison functions.
.I rb_insert
returns 1 on success
and 0 on failure.
.PP
.I rb_extreme
searches through
.I tree
to find a minimum or maximum node in one of the orders
as determined by the corresponding comparison function.
.I Sense
is either
.I SENSE_MIN
or
.I SENSE_MAX,
and
.I order
specifies which order to search.
.I rb_extreme
returns a pointer to the extreme data.
The macros
.I rb_min(tree, order)
and
.I rb_max(tree, order),
available in
\fI"redblack.h"\fR,
are implemented in terms of
.I rb_extreme
in the obvious way.
.PP
.I rb_search
traverses
.I tree
searching for a node of which the contents equals
.I data
according to the comparison function
specified by
.I order.
On success,
.I rb_search
returns a pointer to the data in the
matching node.
Otherwise, it returns
.I NULL.
The macro
.I rb_search1(tree, data),
available in
\fI"redblack.h"\fR,
is similar,
except that it searches the first (perhaps only) order.
.PP
.I rb_walk
traverses
.I tree
according to the comparison function specified by
.I order
and applies a specified funtion.
.I Visit
is called for each node in turn,
with one argument that points
to the data at that node.
.PP
Libredblack maintains an internal pointer called
.I current_node
that points to the node most recently inserted, accessed, etc.
The following commands make use of
.I current_node
for various relative-addressing purposes.
.PP
.I rb_neighbor
finds the node adjacent to
.I current_node
in one of the orders.
.I Order
specifies the order
and
.I sense,
one of
.I SENSE_MIN
and
.I SENSE_MAX,
specifies either predecessor or successor, respectively.
The macros
.I rb_pred(order)
and
.I rb_succ(order),
available in
\fI"redblack.h"\fR,
are implemented in terms of
.I rb_neighbor
in the obvious way.
.\"
.SH SEE ALSO
qsort(3)
.\"
.SH AUTHOR
Paul Tanenbaum
