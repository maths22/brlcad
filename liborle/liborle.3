.TH LIBRLE 3V VMB
'\"	last edit:	85/03/26	G. S. Moss
'\"	SCCS ID:	@(#)librle.3	1.4
.SH NAME
librle \- run-length encoded image library
.SH SYNOPSIS
.nf
.B #include ``/vld/include/rle.h''
.B #include ``/vld/include/fb.h''
.P
\fBint rle_rhdr( stream, flags, bgpixel, xsize, ysize, xpos, ypos )\fR
.B FILE *stream;
.B int *flags;
.B Pixel *bgpixel;
.B int *xsize, *ysize;
.B int *xpos, *ypos;
.P
\fBrle_whdr( stream, ncolors, bgflag, cmflag, bgpixel )\fR
.B FILE *stream;
.B Pixel *bgpixel;
.P
.B int rle_rmap( stream, cmap )
.B FILE *stream;
.B ColorMap *cmap;
.P
.B rle_wmap( stream, cmap )
.B FILE *stream;
.B ColorMap *cmap;
.P
.B rle_decode_ln( stream, scanline_buffer )
.B FILE *stream;
.B Pixel *scanline_buffer;
.P
.B rle_encode_ln( stream, scanline_buffer )
.B FILE *stream;
.B Pixel *scanline_buffer;
.P
.SH DESCRIPTION
These routines are designed to provide a means of decoding or encoding
\fIUniversity of Utah\fR format \fIRun-Length Encoded\fR (RLE) files
from a
.B
.SM C
program.
There are seperate routines for reading or writing the
.B
.SM RLE
header, reading
or writing the encoded color map and decoding or encoding a scanline of a
raster image.  The program that loads this library can be ignorant of the
.B
.SM RLE
scheme being used.  This library does not need to know anything about
the framebuffer hardware being used.
The framebuffer library,
.IR libfb\^ (3V),
can be used to free the program of hardware dependence.
.P
These routines are used to decode an
.B
.SM RLE
file into a raster image.
.P
.I Rle_rhdr\^
will seek to the beginning of the named input stream and reads the
set up information in the
.B
.SM RLE
header.  This routine
must be called first when decoding an
.B
.SM RLE
file.
If
.I bgpixel\^
is not
.B
.SM NULL,
the background color stored in the
.B
.SM
RLE
header will be placed there.  The horizontal and vertical dimension of the
image in pixels will be placed in
.I xsize\^
and
.IR ysize\^ ,
and the coordinates of the lower left corner of the image will be stored
in
.I xpos\^
and
.IR ypos\^ .
.I Flags\^
is a flag word using bit flags
.B
.SM NO_BOX_SAVE,
.B
.SM NO_COLORMAP,
and
.B
.SM NO_IMAGE
(described in
.BR rle.h )
to indicate whether or not the image was saved with background,
whether the color map was saved,
and whether or not the image was saved (or just the color map).
If the color map was saved,
.I rle_rmap\^
must be used next to read the color map from the
.B
.SM RLE
file and decode it into the buffer
pointed to by
.I cmap\^.
.P
.I Rle_decode_ln\^
is used to decode the next scanline (starting at the bottom) and
should be passed the address of
.I scanline_buffer\^
large enough to store
.I xsize\^
pixels.
Only foreground pixels are written, it is the caller's responsibility
to fill the buffer first with the appropriate background.  If no
foreground pixels occur, zero is returned, otherwise 1 is returned
to indicate that the buffer has been altered.
.P
These routines are used to compress a raster image into an
.B
.SM RLE
file.
.P
.I Rle_whdr\^
is used first to specify the encoding scheme to use and to
write the
.B
.SM RLE
header to the named output stream which will contain this information.
The
.I ncolors\^
parameter specifies the number of color channels.  Normally, this should
be set to 3 for red, green, and blue channels.  If
.I ncolors\^
equals 1, a monochrome (black and white) image is assumed, and if
it is 0, only the color map will be saved.
The
.I bgflag\^
specifies whether or not the image is saved with the background.  If
.I bgflag\^
is set, only the foreground image is saved.  If the flag is reset,
the entire image is encoded.
.I Rle_whdr\^
stores the background color along with the other set up information.
If a monochrome image has been specified, the
.B
.SM NTSC
standard is used to calculate the background color from
.IR bgpixel\^ ,
otherwise
.I bgpixel\^
is used as the background color.
The
.I cmflag\^
is used to indicate that the color map is to be saved and this is
accomplished with
.I rle_wmap\^
which must be used next to encode the color map pointed to by
.I cmap\^
and write it to the
.B
.SM RLE
file.  If the value of
.I cmap\^
is
.B
.SM NULL,
a standard (linear) color map will be written.
.P
.I Rle_encode_ln\^
is used to encode the next scanline (starting at the bottom) and
should be passed the address of
.I scanline_buffer\^
which contains the pixels to be converted.
.P
The
.I Pixel\^
and
.I ColorMap\^
data types are defined in
.BR fb.h .
The color map and scanlines can be conveniently read or written from
a file or supported framebuffer with compatible functions found in
.IR libfb (3V).
.SH WARNINGS
The
.B
.SM RLE
files must be decoded seqentially from the bottom, up as it is the convention
that the origin be the lower left corner of the screen.
.I Rle_decode_ln\^
should fail if called more than
.I ysize\^
times as it will attempt to read past the end of the input file.
Encoding an
.B
.SM RLE
file from the top, down is considered anti-social behavior and will lead
to confusion if the installed utilities are used.
The functions must be used in sequence to read/write the header, followed
by the color map (if one exists) and then the image.
It is fine to process multiple images as long as the proper sequence
is followed.
Both
.I rle_rhdr\^
and
.I rle_whdr\^
seek to the beginning of
.I stream\^
before performing any I/O, but all other functions rely on sequential
read/write operations on the
.B
.SM RLE
file.  It is not recommended to process 2 images asynchronously, that is,
you should finish one before you begin the next.
The problem stems from the fact that some global information is stored by
.IR rle_rhdr\^ ,
which is clobbered by subsequent calls.
Therefore,
if switching back to an image that is partially decoded, the file offset
must be determined with
.IR ftell\^ (3)
and then
.I rle_rhdr\^
can be envoked again to set up things and finally
.IR fseek\^ (3)
used to reposition the file pointer.
.SH DISCUSSION
It would be nice to fix the problem of asynchronous calls by passing a
pointer to storage for the set up structure to the read/write header and
read/write scanline routines so that there is no global information
to contend with.
.SH EXAMPLE
The library may be loaded as follows:
.RS
$ \|\fIcc \|\-I/vld/include \|program.c \|\/vld/lib/librle.a\fP
.RE
.SH FILES
/vld/include/rle.h
.br
/vld/include/fb.h
.br
/vld/lib/librle.a
.SH "SEE ALSO"
libfb(3V)
.SH DIAGNOSTICS
All functions will print a message and return a -1 upon error.
.SH AUTHOR
Gary S. Moss, BRL/VLD-VMB
Mike J. Muuss, BRL/SECAD
Spencer W. Thomas, U. of Utah
