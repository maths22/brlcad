/*
 *			S U N - P I X . C
 *
 *  Program to take Sun bitmap files created with Sun's ``screendump''
 *  command, and convert them to pix(5) format files.
 *
 *  Authors -
 *	Phillip Dykstra
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@(#)$Header$ (BRL)";
#endif

#include <stdio.h>

/*
 * Description of header for files containing raster images
 */
struct rasterfile {
	int	ras_magic;		/* magic number */
	int	ras_width;		/* width (pixels) of image */
	int	ras_height;		/* height (pixels) of image */
	int	ras_depth;		/* depth (1, 8, or 24 bits) of pixel */
	int	ras_length;		/* length (bytes) of image */
	int	ras_type;		/* type of file; see RT_* below */
	int	ras_maptype;		/* type of colormap; see RMT_* below */
	int	ras_maplength;		/* length (bytes) of following map */
	/* color map follows for ras_maplength bytes, followed by image */
} header;
#define	RAS_MAGIC	0x59a66a95

	/* Sun supported ras_type's */
#define RT_OLD		0	/* Raw pixrect image in 68000 byte order */
#define RT_STANDARD	1	/* Raw pixrect image in 68000 byte order */
#define RT_BYTE_ENCODED	2	/* Run-length compression of bytes */
#define RT_EXPERIMENTAL 0xffff	/* Reserved for testing */

	/* Sun registered ras_maptype's */
#define RMT_RAW		2
	/* Sun supported ras_maptype's */
#define RMT_NONE	0	/* ras_maplength is expected to be 0 */
#define RMT_EQUAL_RGB	1	/* red[ras_maplength/3],green[],blue[] */

/*
 * NOTES:
 * 	Each line of the image is rounded out to a multiple of 16 bits.
 *   This corresponds to the rounding convention used by the memory pixrect
 *   package (/usr/include/pixrect/memvar.h) of the SunWindows system.
 *	The ras_encoding field (always set to 0 by Sun's supported software)
 *   was renamed to ras_length in release 2.0.  As a result, rasterfiles
 *   of type 0 generated by the old software claim to have 0 length; for
 *   compatibility, code reading rasterfiles must be prepared to compute the
 *   true length from the width, height, and depth fields.
 */

int	pixout = 1;		/* 0 = bw(5) output, 1 = pix(5) output */
int	hflag;
int	inverted;
int	pure;			/* No Sun header */
int	byteswap;		/* Need to byte swap */

FILE	*fp = stdin;

char	usage[] = "\
Usage: sun-pix [-b -h -i -P] [sun.bitmap]\n";

main( argc, argv )
int argc;
char **argv;
{
	register int	i, c;

	while( argc > 1 ) {
		if( strcmp( argv[1], "-b" ) == 0 )
			pixout = 0;
		else
		if( strcmp( argv[1], "-h" ) == 0 )
			hflag++;
		else
		if( strcmp( argv[1], "-i" ) == 0 )
			inverted++;
		else
		if( strcmp( argv[1], "-P" ) == 0 )
			pure++;
		else
			break;
		argc--;
		argv++;
	}

	if( argc > 1 ) {
		if( (fp = fopen( argv[1], "r" )) == NULL ) {
			fprintf( stderr, "Can't open file\n" );
			exit( 1 );
		}
	} else if( isatty(fileno(stdin)) ) {
		fprintf( stderr, usage);
		exit( 2 );
	}

	if( !pure )
		fread( &header, sizeof(header), 1, fp );

	if( header.ras_magic != RAS_MAGIC )  {
		if( ntohl(header.ras_magic) != RAS_MAGIC )  {
			fprintf(stderr,
				"bad magic number, was x%x, s/b x%x\n",
				header.ras_magic, RAS_MAGIC );
			exit(1);
		}
		header.ras_width = ntohl(header.ras_width);
		header.ras_height = ntohl(header.ras_height);
		header.ras_depth = ntohl(header.ras_depth);
		header.ras_length = ntohl(header.ras_length);
		header.ras_maplength = ntohl(header.ras_maplength);
	}

/*
	fprintf( stderr, "ras_width = %d, ras_height = %d, ras_depth = %d, ras_length = %d\n",
		header.ras_width, header.ras_height, header.ras_depth, header.ras_length );
*/
	if( hflag ) {
		printf( "-w%d -n%d\n", header.ras_width, header.ras_height );
		exit( 0 );
	}

	/*  Gobble colormap */
	for( c=0; c<header.ras_maplength; c++)  {
		(void)getchar();
	}

	/* For now, assume 1-bit image */
	while( !feof(fp) ) {
		c = getc(fp);
		if( inverted ) {
			for( i = 0x80; i > 0; i >>= 1 )
				if( c & i ) {
					putchar( 0 );
					if(pixout){putchar(0);putchar(0);}
				} else {
					putchar( 255 );
					if(pixout){putchar(255);putchar(255);}
				}
		} else {
			for( i = 0x80; i > 0; i >>= 1 )
				if( c & i ) {
					putchar( 255 );
					if(pixout){putchar(255);putchar(255);}
				} else {
					putchar( 0 );
					if(pixout){putchar(0);putchar(0);}
				}
		}
	}
}
